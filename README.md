# Контрольные задания по курсу Алгоритмы и структуры данных (ИУ-8 Компьютерная безопасность) 

## Module_1 содержит 4 программы на тему базовых структур данных

### Задача про сумму
На стандартном потоке ввода задаётся последовательность целых чисел.
Каждое число последовательности не меньше -200 000 000 и не больше 200 000 000.
На стандартный поток вывода напечатайте сумму этих чисел.

### Задача про стек
Реализуйте стек, используя только массив.
#### Формат входных данных
На стандартном потоке ввода задаётся последовательность команд. Пустые строки игнорируются.
Первая строка всегда содержит "set_size N", где N - максимальный размер стека, целое число.
Каждая последующая строка содержит ровно одну команду: push X, pop или print, где X - произвольная строка без пробелов.
#### Формат результата
Команда print выводит содержимое стека (снизу вверх) одной строкой, значения разделяются пробелами. Если стек пуст, то выводится "empty".
В случае переполнения стека выводится "overflow".
Команда pop выводит элемент или "underflow", если стек пуст.
Память под стек должна быть выделена не более одного раза, при вызове команды "set_size".
В любой непонятной ситуации результатом работы любой команды будет "error".
Результат работы программы выводится в стандартный поток вывода.

### Задача про очередь
Это как задача про стек, только про очередь.
Реализуйте очередь, используя только массив.
Ввод и вывод данных осуществляется через файлы. Имена входного и выходного файлов задаются через аргументы командной строки (первый и второй соответственно).
#### Формат входных данных
Во входном файле задаётся последовательность команд. Пустые строки игнорируются.
Первая строка всегда содержит "set_size N", где N - максимальный размер очереди, целое число.
Каждая последующая строка содержит ровно одну команду: push X, pop или print, где X - произвольная строка без пробелов.
#### Формат результата
Команда print выводит содержимое очередь (от головы к хвосту) одной строкой, значения разделяются пробелами. Если очередь пуста, то выводится "empty".
В случае переполнения очереди выводится "overflow".
Команда pop выводит элемент или "underflow", если очередь пуста.
Память под очередь должна быть выделена не более одного раза, при вызове команды "set_size".
В любой непонятной ситуации результатом работы любой команды будет "error".

### Задача про обход графа
Реализуйте обход графа в ширину и глубину.
Вершины упорядочены в лексикографическом порядке.
#### Формат входных данных
Первая строка стандартного потока ввода данных имеет формат "[graph_type] [start_vertex] [search_type]",
где "[graph_type]" - тип графа, ориентированный ('d') или неориентированный ('u');
"[start_vertex]" - идентификатор вершины, с которой начинать обход графа;
"[search_type]" - тип обхода, в ширину ('b') или в глубину ('d').
Каждая последующая строка содержит ребро, которая представляет собой идентификаторы начальной и конечной вершины, разделенные пробелом.
#### Формат результата
Результат работы программы выводится в стандартный поток вывода.
Идентификаторы посещенных вершин выводятся по одному в строке в порядке обхода.

## Module_2 содержит 3 программы по теме алгоритмы (жадный алгоритм, алгоритм Демерау-Левенштейна)

### Рюкзак
Решите задачу о рюкзаке методом динамического программирования. Алгоритм должен быть инкапсулирован.
#### Формат входных данных
Данные подаются на стандартный поток ввода. Пустые строки игнорируются.
Первая строка содержит натуральное число - максимальную массу предметов, которую выдержит рюкзак.
Каждая последующая содержит два неотрицательных числа: массу предмета и его стоимость.
#### Формат результата
Первая строка содержит два числа: суммарную массу предметов и их суммарную стоимость.
В последующих строках записаны номера предметов, которые были помещены в рюкзак, в порядке возрастания номера.
Результат работы программы выводится в стандартный поток вывода.

### Сумасшедший богач
Один сумасшедший богач на старости лет впал в маразм и стал еще более сумасшедшим. Он решил отдать половину своих богатств тому, кто выиграет в математической игре.
Правила игры: изначально каждый игрок начинает с нулевой суммой. Он может либо получить у богача 1 миллион сантиков, либо отдать ему 1 миллион сантиков, либо получить от богача ту же сумму, которая есть у него сейчас.
Выигрывает тот, кто за минимальное количество действий наберет сумму, равную половине состояния богача.
На беду других игроков, нашелся человек, который что-то слышал про жадные алгоритмы и двоичную систему счисления (возможно это вы).
#### Формат входных данных
В стандартном потоке записано единственное натуральное число - размер половины состояния богача (в миллионах).
#### Формат результата
Каждая строка выхода содержит ровно одну операцию (inc, dec или dbl) из кратчайшей последовательности действий для победы.
Если кто-то решил отнимать деньги у умалишенных людей - значит, он очень жадный.
Поэтому если решений несколько, выведите то, в котором больше операций удвоения суммы (и отдавать деньги невменяемым людям стоит только при крайней необходимости).
Результат работы программы выводится в стандартный поток вывода.

### Автокоррекция
Реализуйте программу, которая предлагает варианты замены слова, в котором допущена одна ошибка.
Эту задачу можно решить достаточно многими способами - на это ограничений нет, но код должен быть хорошего качества и читаемым.
Регистр букв для программы коррекции не имеет значения (слова в словаре хранятся в нижнем регистре).
Варианты ошибок - как в алгоритме Дамерау-Левенштейна: вставка лишнего символа, удаление символа, замена символа или транспозиция соседних символов.
#### Формат входных данных
Данные подаются на стандартный поток ввода. Пустые строки игнорируются.
Первая строка содержит число N - количество слов в словаре.
Последующие N строк содержат слова из словаря, по одному в строке.
Остальные строки - слова, которые надо проверять.
#### Формат результата
Каждая строка выхода содержит предложение для исправления слов, в порядке их появления.
Если слово не содержит ошибок, то выводится "%слово% - ok".
Если слово содержит одну ошибку, то выводится "%слово% -> %слово_в_словаре%". Если вариантов несколько, то они разделяются запятой с пробелом.
Если слово содержит более одной ошибки, то выводится "%слово% -?"
Результат работы программы выводится в стандартный поток вывода.
